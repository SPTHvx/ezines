xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
									DIZAHEX DISASSEMBLER ENGINE
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
												v1.0
												2013
												
РУКОВОДСТВО ПОЛЬЗОВАТЕЛЯ

Дизассемблер DIZAHEX.
Двигатель тщательно тестировался на различных исполняемых файлах и автоматически сгенерированных 
инструкциях. По идее работает отлично. А если ты надёшь какие-либо неточности, ошибки в работе движка - 
пожалуйста, сообщи мне об этом. 
Замечания, предложения, пожелания приветствуются!			

																m1x
																pr0mix@mail.ru
																вирмэйкинг для себя...искусство вечно
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
									DIZAHEX DISASSEMBLER ENGINE
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx



---------------------------------------------------------------------------------------------------------

[ОПИСАНИЕ]
	DIZAHEX - небольшой дизассемблерный движок, предназначенный для анализа x86/x86-64 (+ 16-разрядного) 
кода. Может использоваться как самостоятельный двигл, так и совместно с какими-либо другими движками: 
пермутатор, эмулятор, виртуальная машина итд. Варианты применения прежде всего в вирусах/червях/троянах, 
навесных защитах (пакеры, крипторы, протекторы) =). А также в других программах.

	DIZAHEX написан на Си, поэтому у него нет привязки к какому-либо процессору. И его можно использовать 
как в 32-х битных, так и в 64-х битных приложениях. Ещё одна особенность движка - у него нет неверных 
инструкций. То есть считается, что весь код, который анализируется - состоит из правильных команд (ёба,
а так программы и пишутся). При желании можно написать внешний анализатор под требуемые задачи. 

	Таблица характеристик опкодов (dizahex_table) является глобальным массивом. Ты можешь сделать дизасм 
пермутируемым, например, перенеся таблицу в функцию dizahex_disasm(), или передав указатель на таблицу 
как (новый) аргумент функции dizahex_disasm().



---------------------------------------------------------------------------------------------------------

[ФИЧИ]
	[+] поддержка x86/x86-64 (+ 16 bits) инструкций;
	[+] поддержка general-purpose, system, fpu, mmx, sse, sse2, sse3, 3dnow!, undocumented инструкций; 
	[+] базонезависимый код (пригоден для пермутации - условие читай выше);
	[+] дизассемблирование инструкции и её сборка (dizahex_disasm(), dizahex_asm());
	[+] нет привязки к процессору;
	[+] нет привязки к ОСи; 
		


---------------------------------------------------------------------------------------------------------

[ИСПОЛЬЗОВАНИЕ]
	DIZAHEX может как разбирать инструкцию на структурку, так и собирать структуру обратно в команду. 
Для дизассемблирования инструкции нужно вызвать функцию 

		int dizahex_disasm(uint8_t *pcode, DIZAHEX_STRUCT *pdiza);
		
Где pcode - указатель на код, a pdiza - указатель на структу DIZAHEX_STRUCT. Перед вызовом данной функи 
структуру DIZAHEX_STRUCT можно не обнулять - движок сам это сделает. Но в поле pdiza->mode следует 
указать режим дизассемблирования: DISASM_MODE_32 или DISASM_MODE_64. 
	
	В результате функция возвратит длину разобранной инструкции и заполнит структуру DIZAHEX_STRUCT, 
которая выглядит так:
	
		typedef struct
		{
			uint8_t		mode;			//режим дизассемблирования	(DISASM_MODE_32/DISASM_MODE_64)
			uint8_t		len;			//длина команды
			uint8_t		pfx_66;			//префикс размера операнда	(0x66)
			uint8_t		pfx_67;			//префикс размера адреса	(0x67)
			uint8_t		pfx_seg;		//префикс сегмента			(0x26/0x2E/0x36/0x3E/0x64/0x65)
			uint8_t		pfx_rep;		//префикс повторения 		(0xF2/0xF3)
			uint8_t		pfx_lock;		//префикс блокировки		(0xF0)
			uint8_t		pfx_rex;		//префикс REX				([0x40..0x4F])
			uint8_t		opcode;			//опкод
			uint8_t		opcode_2;		//2-ой опкод (если 1-ый опкод = 0x0F)
			uint8_t		modrm;			//байт MODRM
			uint8_t		sib;			//SIB
			union
			{
				uint8_t		disp_8;		//DISP_8 	(1-байтное смещение)
				uint16_t	disp_16;	//DISP_16	(2-байтное смещение)
				uint32_t	disp_32;	//DISP_32	(4-байтное смещение)

			}disp;
			union
			{
				uint8_t		imm_8;		//IMM_8		(1-байтовое непосредственное значение)
				uint16_t	imm_16;		//IMM_16	(2-байтовое непосредственное значение)
				uint32_t	imm_32;		//IMM_32	(4-байтовое непосредственное значение)
				uint64_t	imm_64;		//IMM_64	(8-байтовое непосредственное значение)
			}imm;
			uint32_t	flags;			//флаги; 
		}DIZAHEX_STRUCT;
		
	После отработки дизасма на выходе всегда заполняются поля pdiza->len и pdiza->opcode. Наличие 
остальных полей можно определить по флагам в pdiza->flags:

		#define F_MODRM				0x00000001	//присутствует байт MODRM
		#define F_SIB				0x00000002	//SIB
		#define F_DISP_8			0x00000010	//DISP_8
		#define F_DISP_16			0x00000020	//DISP_16
		#define F_DISP_32			0x00000040	//DISP_32
		#define F_IMM_8				0x00000100	//IMM_8
		#define F_IMM_16			0x00000200	//IMM_16
		#define F_IMM_32			0x00000400	//IMM_32
		#define F_IMM_64			0x00000800	//IMM_64
		#define F_REL				0x00001000	//IMM* в команде является относительным адресом
		#define F_COP_IMM_DISP		0x00002000	//меняем порядок обработки IMM и DISP
		#define F_PFX_66			0x00010000	//0x66
		#define F_PFX_67			0x00020000	//0x67
		#define F_PFX_SEG			0x00040000	//присутствует сегментный префикс
		#define F_PFX_REP			0x00080000	//присутствует префикс повторения
		#define F_PFX_LOCK			0x00100000	//LOCK
		#define F_PFX_REX			0x00200000	//REX
		
Здесь следует пояснить назначение некоторых флагов. Итак:
	(+) F_REL. Этим флагом помечаются инструкции относительного перехода: call/jmp/jcc rel32, 
		jcc rel8 etc. При этом значение rel* будет лежать в поле pdiza->imm.imm*;
	(+) F_COP_IMM_DISP (COP - Change Order of Processing). Этим флагом помечаются команды, 
		имеющие 2 непосредственных значения: jmp/call far imm16:imm16/32; enter imm16, imm8.
		Для jmp/call far дизасм запишет imm16/32 в поле pdiza->imm.imm*, а imm16 в 
		pdiza->disp.disp_16. Для enter: imm16 в pdiza->imm.imm_16, imm8 в pdiza->disp.disp_8 
		(то есть байты обрабатываются поочерёдно в порядке их следования в команде); 
		
	Для ассемблирования инструкции нужно вызвать функцию 

		int dizahex_asm(uint8_t *pcode, DIZAHEX_STRUCT *pdiza);
		
Где pcode - указатель на код, a pdiza - указатель на заполненную структу DIZAHEX_STRUCT. В результате 
функция возвратит длину собранной инструкции. 
		
		
		
---------------------------------------------------------------------------------------------------------

[ИСТОРИЯ]
	v1.0	:
				релиз - первая открытая версия!
				
				
				
---------------------------------------------------------------------------------------------------------

Спасибо herm1t'у за тестирование движка =).				
