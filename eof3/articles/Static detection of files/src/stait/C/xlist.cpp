/***************************************************************************************************************\
*																												*
*							МОДУЛЬ ДЛЯ РАБОТЫ СО ОДНОНАПРАВЛЕННЫМ СВЯЗНЫМ СПИСКОМ								*
*												(ОПРЕДЕЛЕНИЯ)													*
*																												*
*		Список используется для хранения/сортировки/etc данных, взятых с таблиц импорта разных PE-файлов		*
*																												*
*	InitList, ShowListAll, DestroyListAll, AddElemDll, AddElemFunc, GetInfoAll, FindElem, SwapElem, BubbleSort	*
*																												*
\***************************************************************************************************************/



#include "xlist.h"



/***************************************************************************************************\
*	Функция InitList
*	Инициализация списка list_dll_node
*	Вход:
*		p	-	указатель на объект list_dll;
*	Выход:
*		иницализация списка (пустой список);
\***************************************************************************************************/
void InitList(list_dll *p)
{
	p->pFirst = 0;	//собсно, само обнуление ) 
}
/***************************************************************************************************\
*	Конец функи InitList; 
\***************************************************************************************************/



/***************************************************************************************************\
*	Функция WriteListAll
*	Запись в файл всех полученных связных списков (запись в файл данных по найденным в импортах 
*		разных PE-files dll & functions)
*	Вход:
*		p		-	указатель на объект list_dll (должен содержать значение, иначе 0);
*		file	-	указатель на объект FILE (в файл идет запись);
*		pgifle	-	указатель на объект GIFL (объект должен быть заполненным);
*	Выход:
*		запись в лог-файл, если все отлично=)!
\***************************************************************************************************/
void WriteListAll(list_dll *p, FILE *file, GIFL *pgifl)
{
	double pr_dll = 0;
	double pr_for_this_dll = 0;
	double pr_for_all_dll = 0;
	double pr_group_func = 0;
	list_dll_node *pldn_next = p->pFirst;	//pldn_next теперь указывает на голову (начало) списка list_dll_node; 
	char szsng_line[] = "-----------------"; 
	char szdbl_line[] = "===================================";  
	char szInfo[] = "INFO FROM PE32-FILES (IMPORT TABLE)"; 
	char szTotal[] = "RESULT FROM LIST";
	int m_count[3] = {1, 1, 1};	//счетчики: [0] - номер уникальной длл в списке; [1] - номер уникальной функи в конкретной длл; [2] - номер уникальной функи во всем списке; 

	fprintf(file, "%s\n%s\n%s\n\n", szdbl_line, szInfo, szdbl_line);

	while(pldn_next)
	{
		list_func_node *plfn_next = pldn_next->pFirst;	//plfn_next теперь указывает на голову (начало) списка list_func_node; 
		pr_dll = ((double)pldn_next->count * MAX_PER) / (double)pgifl->num_all_dll;	//вычисляем процентное соотношение количеств длл;
		pr_group_func = ((double)pldn_next->num_all_func * MAX_PER) / (double)pgifl->num_all_func;	//процентное соотношение кол-тв групп функций (т.е. соотношение кол-ва функций (включая их повторения) в данной длл к кол-ву всех функций во всех длл);     
		fprintf(file, "%s\n%s\n%d\n", szdbl_line, szdbl_line, m_count[0]);
		fprintf(file, "%s\n%d\n%d\n%d\n%3.5f%%\n%3.5f%%\n%s\n", pldn_next->pName, pldn_next->count, pldn_next->num_func, 
				pldn_next->num_all_func, pr_dll, pr_group_func, szdbl_line);	//и записываем все это дело в файл; 

		while(plfn_next)
		{
			pr_for_this_dll = ((double)plfn_next->count * MAX_PER) / (double)pldn_next->num_all_func;	//процентное соотношение кол-ва одной функции (включая повторения) в данной длл к кол-ву всех функций в данной длл;
			pr_for_all_dll = ((double)plfn_next->count * MAX_PER) / (double)pgifl->num_all_func;	//процентное соотношение кол-ва одной функи (включая ее повторения) в данной длл к кол-ву всех фунок во всех длл; 
			fprintf(file, "%d | %d\n", m_count[1], m_count[2]); 
			fprintf(file, "%s\n%d\n%3.5f%%\n%3.5f%%\n%s\n", plfn_next->pName, plfn_next->count, pr_for_this_dll, 
					pr_for_all_dll, szsng_line); 
			m_count[1]++;
			m_count[2]++;
			plfn_next = plfn_next->pNext;	//переход на следующий элемент списка; 
		}

		fprintf(file, "%s\n%s\n\n\n\n", szdbl_line, szdbl_line); 
		m_count[0]++;
		m_count[1] = 1;
		pldn_next = pldn_next->pNext;
	}
 
	fprintf(file, "%s\n%s\n%s\nnum_dll_in_list\t\t=\t%d\nnum_all_dll_in_list\t=\t%d\nnum_func_in_list\t=\t%d\nnum_all_func_in_list\t=\t%d\n%s\n", 
		szdbl_line, szTotal, szdbl_line, pgifl->num_dll, pgifl->num_all_dll, pgifl->num_func, pgifl->num_all_func, szdbl_line);
}
/***************************************************************************************************\
*	Конец функи WriteListAll; 
\***************************************************************************************************/



/***************************************************************************************************\
*	Функа DestroyListAll
*	Освобождение памяти, ранее выделенной для связных списков; 
*	Вход:
*		p	-	указатель на объект list_dll;
*	Выход:
*		(+)
\***************************************************************************************************/
void DestroyListAll(list_dll *p)
{
	list_dll_node *pldn_next = p->pFirst;	//получаем голову списка list_dll_node;

	while(p->pFirst)
	{
		pldn_next = p->pFirst;	//сохраняем адрес первого элемента в списке - его мы и будем удалять;
		p->pFirst = p->pFirst->pNext;	//делаем теперь второй элемент первым; 
		list_func_node *plfn_next = pldn_next->pFirst;	//получаем голову списка list_func_node;
		
		while(pldn_next->pFirst)
		{
			plfn_next = pldn_next->pFirst; //etc 
			pldn_next->pFirst = pldn_next->pFirst->pNext;
			free(plfn_next->pName);	//освобождаем сначала память, выделенную под строку;
			free(plfn_next);	//а затем освободим сам элемент списка;
		}

		free(pldn_next->pName);	//etc 
		free(pldn_next);
	}
}
/***************************************************************************************************\
*	Конец функи DestroyListAll; 
\***************************************************************************************************/



/***************************************************************************************************\
*	Функа AddElemDll
*	 Добавление очередного элемента (данных о новой найденной длл) в список 
*	(если же такой элемент в списке есть, тогда делаем инкремент счетчика этого элемента)
*	Вход:
*		p			-	указатель на объект структуры list_dll;
*		pszDllName	-	указатель на имя длл. "Эту длл" мы и хотим добавить в список. 
*	Выход:
*		1			-	если добавлен новый элемент, иначе 0 (элемент уже есть в списке); 		
*	Заметки:
*		Вначале мы должны проверить, есть ли данная длл уже у нас в списке. Для этого мы производим 
*		поиск в списке по имени длл (pszDllName). Эта строка должна быть вся в нижнем регистре, 
*		так как в списке имена длл хранятся именно в таком виде. Имена функций хранятся  в 
*		нормальном виде;
\***************************************************************************************************/
BOOL AddElemDll(list_dll *p, char *pszDllName)
{ 	
	int fld;
	list_dll_node *pldn;
	list_dll_node *pldn_next = FindElemDll(p, pszDllName, &fld);	//вначале проверим, есть ли элемент уже в списке

	if(!fld)	//элемент не был найден? 
	{
		int len = strlen(pszDllName);	//получим длину строки
		pldn = (list_dll_node*)malloc(sizeof(list_dll_node));	//выделим память для нового элемента списка;
		pldn->pName = (char*)malloc(sizeof(char) * len + 1);	//выделим память для строки, адрес данного участка памяти сохранен в pName; 
		strcpy(pldn->pName, pszDllName);	//скопируем строку;
//		pldn->pDllName[len] = 0;
		pldn->count = 1;	//проинициализируем переменные нового элемента; 
		pldn->num_func = 0;
		pldn->num_all_func = 0; 
		pldn->pFirst = 0;

		if(!p->pFirst)	//если список пустой
		{
			p->pFirst = pldn;
			pldn->pNext = 0;
		}
		else	//если список содержал уже хотя бы один элемент, тогда добавим новый элемент в конец списка; 
		{
			pldn_next->pNext = pldn;
			pldn->pNext = 0; 
		}

		return 1; 
	}
	else
		pldn_next->count++;

	return 0;
}
/***************************************************************************************************\
*	Конец функи AddElemDll; 
\***************************************************************************************************/



/***************************************************************************************************\
*	Функа AddElemFunc
*	 Добавление очередного элемента (данных о новой найденной функе) в список 
*	(если же такой элемент в списке есть, тогда делаем инкремент счетчика этого элемента)
*	Вход:
*		p	-	указатель на объект list_dll;
*		pszDllName	-	указатель на строку - имя длл;
*		pszFuncName	-	указатель на строку - имя функи;
*	Выход:
*		1			-	если добавлен новый элемент, иначе 0 (элемент уже есть в списке);
*	Заметки:
*		Вначале мы ищем элемент-длл, в котором содержится указатель на начало списка 
*		list_func_node (там, где хранятся данные по каждой функе, принадлежащей данной длл); А сам 
*		поиск производим по имени pszDllName. Эта строка должна быть вся в нижнем регистре. 
*		Затем мы проверяем, есть ли данная функа в этом списке list_func_node. Ищем по имени 
*		pszFuncName.
\***************************************************************************************************/
BOOL AddElemFunc(list_dll *p, char *pszDllName, char *pszFuncName)
{
	int fld;
	int flf;
	list_func_node *plfn;
	list_dll_node *pldn_next = FindElemDll(p, pszDllName, &fld);	//поиск  элемента (длл), которая по идее импортирует нужную нам функу (винапишку); 
	list_func_node *plfn_next = FindElemFunc(pldn_next, pszFuncName, &flf);	//поиск элемента (функи) в найденной (по-любому найденной=)) длл (элемент);

	if(fld)	//etc
	{
		pldn_next->num_all_func++; 
		 
		if(!flf)
		{
			int len = strlen(pszFuncName);
			plfn = (list_func_node *)malloc(sizeof(list_func_node));
			plfn->pName = (char*)malloc(sizeof(char) * len + 1); 
			strcpy(plfn->pName, pszFuncName);
			plfn->count = 1;
			pldn_next->num_func++;

			if(!pldn_next->pFirst)
			{
				pldn_next->pFirst = plfn;
				plfn->pNext = 0;
			}
			else
			{
				plfn_next->pNext = plfn;
				plfn->pNext = 0; 
			}

			return 1; 
		}
		else
			plfn_next->count++;
	}
	else
	{
	} 

	return 0; 
}
/***************************************************************************************************\
*	Конец функи AddElemFunc; 
\***************************************************************************************************/



/***************************************************************************************************\
*	Шаблон функции FindElem
*	поиск элемента в спике (list_dll_node или list_func_node)
*	Вход:
*		p		-	указатель на объект структуры B, в котором содержится указатель на начало 
*						A; вот такая хуйня )
*		pszName	-	имя (указатель на строку), по которому будет идти поиск;
*		fl		-	сюда передать адрес переменной, в которой на выходе сохранится 0 - если элемент 
*						отсутствует в списке, и 1 - если элемент найден;
*	Выход:
*		указатель на элемент структуры A. Если элемент был найден, тогда указатель будет 
*			содержать адрес этого элемента в списке. Если же элемент не был найден, тогда 
*			указатель будет содержать адрес пустого элемента в списке (конец списка) - вот сюда после 
*			и будет добавлен новый элемент; 
*		fl;		
*	Заметки:
*		смотри в сорцы и все станет понятн0 )
\***************************************************************************************************/
template <class A, class B>
A *FindElem(B *p, char *pszName, int *fl)
{
	A *pl_next = p->pFirst;	//etc
	*fl = 0;

	while(pl_next) 
	{
		if(strcmp(pl_next->pName, pszName) == 0)	//поиск по имени; 
		{
			*fl = 1;
			break;
		}

		if(!pl_next->pNext)
			break;

		pl_next = pl_next->pNext;
	}

	return pl_next;
}
/***************************************************************************************************\
*	Конец шаблона функи FindElem;  
\***************************************************************************************************/



/***************************************************************************************************\
*	шаблон функи SwapElem; 
*	перестановка смежных элементов (в списке (list_dll_node или list_func_node)) (для пузырьковой 
		сортировки);
*	Вход:
*		p		-	указатель на объект структуры B, в котором содержится указатель на начало A;
*		pPrev	-	"предыдущий" элемент в списке структур A; 
*		pCur	-	"текуший";
*		pNext	-	"следующий";
*	Выход:
*		указатель на новый текущий элемент (так как произошла перестановка текущего и следующиего 
*			элементов между собой); 
\***************************************************************************************************/
template <class A, class B>
A *SwapElem(B *p, A *pPrev, A *pCur, A *pNext)
{
	if(!pPrev)	//если текущий элемент - голова списка;
		p->pFirst = pNext;
	else	//если текущий элемент - любой, кроме головы (к.0.)
		pPrev->pNext = pNext;
	
	pCur->pNext = pNext->pNext; 
	pNext->pNext = pCur;

	return pNext;

}
/***************************************************************************************************\
*	Конец шаблона функи SwapElem;  
\***************************************************************************************************/



/***************************************************************************************************\
*	шаблон функи BubbleSort;  
*	Пузырьковая сортировка (списка (list_dll_node or list_func_node))
*	Вход:
*		p	-	указатель на объект структуры A, в котором содержится указатель на начало B; 
*	Выход:
*		число, сколько всего было перестановок в списке;
*	Заметки:
*		сортировка осуществляется путем сравнения значений полей count (числа повторений элемента 
*		в списке);
*		пузырек - перестановка смежных элементов при истине заданного нами условия; 
*		сортировка в порядке убывания; 
\***************************************************************************************************/
template <class A, class B>
DWORD BubbleSort(A *p)	//	хитрож0пая сортировка ); 
{
	B *pldn_next;
	B *pldn_prev;
	int fl = 0;
	int count = 0;

	while(1)
	{
		pldn_next = p->pFirst; 
		pldn_prev = 0;

		while(pldn_next->pNext)
		{
			if(pldn_next->count < pldn_next->pNext->count)
			{
				pldn_next = SwapElem<B, A>(p, pldn_prev, pldn_next, pldn_next->pNext);
				fl = 1;
				count++;
			}

			pldn_prev = pldn_next;
			pldn_next = pldn_next->pNext; 
		}

		if(!fl)
			break;
		else
			fl = 0;
	}

	return count;
}
/***************************************************************************************************\
*	конец шаблона функи BubbleSort;  
\***************************************************************************************************/



/***************************************************************************************************\
*	функа BubbleSortAll; 
*	 Функа, вызывающая функцию пузырьковой сортировки для всех списков (сортирующая все списки);
*	Вход:
*		p	-	указатель на объект структуры list_dll; (естественно, p - должен содержать 
*					непустое значение); 
*	Выход:
*		число, сколько всего было перестановок во всех списках;
\***************************************************************************************************/
DWORD BubbleSortAll(list_dll *p)
{
	int count = 0;
	list_dll_node *pldn_next;

	if(!p->pFirst)	//если список пустой
		return count;

	count += BubbleSortDll(p);	//сначала отсортируем список list_dll_node;
	pldn_next = p->pFirst;

	while(pldn_next)
	{
		count += BubbleSortFunc(pldn_next);	//а затем каждый список list_func_node; 
		pldn_next = pldn_next->pNext; 
	} 

	return count;
}
/***************************************************************************************************\
*	конец функи BubbleSortAll;   
\***************************************************************************************************/
 


/***************************************************************************************************\
*	Функа GetInfoAll; 
*	Получение разной инфы из списка list_dll_node; 
*	Вход:
*		p		-	указатель на list_dll;
*		pgifl	-	указатель на объект GIFL. Данный объект должен быть обнуленным (все значения 
*						должны быть проинициализированы);
*	Выход:
*		указатель на переданный обэект. Значения структуры заполнены.
\***************************************************************************************************/
GIFL *GetInfoAll(list_dll *p, GIFL *pgifl)
{
	list_dll_node *pldn_next = p->pFirst;	//etc 

	while(pldn_next)
	{
		pgifl->num_dll++;	//считаем уникальные длл (то есть без повторений); 
		pgifl->num_func += pldn_next->num_func;	//считаем уникальные функции (etc) во всех dll; 
		pgifl->num_all_dll += pldn_next->count; //считаем все длл (с повторениями);
		pgifl->num_all_func += pldn_next->num_all_func;	//счиатем все функии (с повторениями) во всех длл; 
		pldn_next = pldn_next->pNext;
	}

	return pgifl;
}
/***************************************************************************************************\
*	конец функи GetInfoAll;   
\***************************************************************************************************/
 
